#!/bin/bash

clear
cd /home/gurov/documents/development/poetry_github/
b_pwd=`pwd` #Эта переменная всегда будет показывать одно и то же
printf "\n"
printf "╔══════════════════════════════════════════════════════════════════════════════════════════════╗\n"
printf "║Приветствую! Добро пожаловать в скрипт gur-o/dev-tmux                                         ║\n"
printf "╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n"
printf "\n"
printf "╔══════════════════════════════════════════════════════════════════════════════════════════════╗\n"
printf "║Какой проект ты хочешь сегодня открыть?                                                       ║\n"
printf "║Мы находимся сейчас в катлоге разработок: $b_pwd \n"
printf "║Посмотри на список проектов и выбери себе один из них                                         ║\n"
printf "╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n"
printf "\n"

# Вывод списка доступных проектов
# printf "\t `ls` \n" # Стандартный не красивый вывод
# Идея в том, чтобы создать текстовый файл со списоком, а потом сделать его красивый вывод на монитор
ls > /tmp/dev-tmux_ls # Вывод содержимого текущего каталога в файл 
cat -b /tmp/dev-tmux_ls # Вывод нумерованного списка из файла

printf "\n"
echo -n "Напишите название проекта, который вы хотите открыть и нажмите ввод: "
read project_name

#Необходимо проверить, существует ли этот катклог. Если нет, вернуться на этап выбора.

function re-enter {
	cd /home/gurov/documents/development/poetry_github/
	b_pwd=`pwd` #Эта переменная всегда будет показывать одно и то же
	printf "\n"
	printf "╔══════════════════════════════════════════════════════════════════════════════════════════════╗\n"
	printf "║Попробуй еще раз, только без ошибок!							       ║\n"
	printf "║Мы находимся сейчас в катлоге разработок: $b_pwd \n"
	printf "║Еще раз посмотри на список проектов и выбери себе один из них 				       ║\n"
	printf "╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n"
	printf "\n"

	# Вывод списка доступных проектов
	# printf "\t `ls` \n" # Стандартный не красивый вывод
	# Идея в том, чтобы создать текстовый файл со списоком, а потом сделать его красивый вывод на монитор
	ls > /tmp/dev-tmux_ls # Вывод содержимого текущего каталога в файл 
	cat -b /tmp/dev-tmux_ls # Вывод нумерованного списка из файла

	printf "\n"
	echo -n "Напишите БЕЗ ОШИБОК название проекта, который вы хотите открыть и нажмите ввод: "
	read project_name
	control_name_1
}

function control_name_1 {
	if [[ -d "$project_name" ]]; then
		printf "\n"
		printf "╔═════════════════════════════════════════════════════╗\n"
		printf "║Каталог $project_name существует                      \n"
		printf "║Все ок, можно продолжать                             ║\n"
		printf "╚═════════════════════════════════════════════════════╝\n"
		printf "\n"

	else
		printf "\n"
		printf "╔══════════════════════════════════════════════════════╗\n"
		printf "║Каталог $project_name НЕ существует                    \n"
		printf "║Дело дрянь... Но мы попробуем разобраться             ║\n"
		printf "╚══════════════════════════════════════════════════════╝\n"
		printf "\n"
		re-enter
	fi
}

control_name_1

cd /home/gurov/documents/development/poetry_github/$project_name
printf "\n"
printf "╔══════════════════════════════════════════════════════════════════════════════════════════════╗\n"
printf "║Переходим в каталог с проектом $project_name \n"
printf "║Теперь мы здесь: `pwd`\n"
printf "║Активируем рабочее пространство tmux							       ║\n"
printf "║Включаем виртуальное окружение poetry							       ║\n"
printf "║Запускам интерпритатор python3 проекта из виртуального окружения			       ║\n"
printf "║Включаем эмулятор терминалa.								       ║\n"
printf "╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n"
printf "\n"

echo -n "Для продолжения нажмите ввод"
read nothing

function create_sess {
	# Это функция создания новой сессии tmux. Она разбита на 2 функции, разделенные паузой из-за невозможности одноврменно запустить poetry shell и последующей любой команды. 
	function session_tmux_new_1 {
	tmux kill-session -t $project_name #На всякий случай убьем сессию, если она существует
	tmux new -s $project_name -n vim -d #Создаем tmux-сессию с названием нашего выбранного проекта и сразу от нее отключаемся, оставляя ее работать как сервер. Также создаем первое окно с названием vim
	# Создаем новое окно 2 рабочего стола - 2:1
	tmux new-window -n develop -t $project_name 
	# Делим окна и присваиваем им номера для дальнейшего управления
	# Для рабочего стола 1
	tmux send-keys -t $project_name:1.1 'poetry shell' Enter #Подключаем poetry
	# Для рабочего стола 2
	tmux split-window -h -t $project_name:2.1 #Разбивам окно 2 рабочего окна
	tmux split-window -v -t $project_name:2.2 #Разбивам окно 2 рабочего окна
	# Записываем, что хотим открыть в этих окнах	
	# Первый рабочий стол
	# 2 рабочий стол
	tmux send-keys -t $project_name:2.1 'poetry shell' Enter # Здесь будет эмулятор терминала c включенным poetry окружением
	tmux send-keys -t $project_name:2.2 'poetry shell' Enter #Запускаем poetry среду и включаем ее python
	tmux send-keys -t $project_name:2.3 'htop' Enter #В верхней панели запускаем htop

	tmux select-window -t $project_name:1.1 #Переводим курсор на окно 1
	}
	function session_tmux_new_2 { # Здесь перечисленны запуски того, что выключается после poetry shell
	tmux send-keys -t $project_name:1.1 'vim' Enter #На всю панель включаем vim (потом сделать программу выбора сессий)
	tmux send-keys -t $project_name:2.2 'python3' Enter #Запускаем poetry среду и включаем ее python
	}
	session_tmux_new_1
	sleep 3
	session_tmux_new_2
	sleep 1
	tmux attach-session -t $project_name #Подключаемся к сессии, после завершения всех настроек
	clear #Очистим терминал 
}

function auth_sess {
	tmux attach-session -t $project_name	
	clear #Очистим терминал 
}

hases="$(tmux has-session -t=$project_name 2> ~/tmp/ba.txt)" #Эта штука создает файл, записывает в файл ошибку нахождения сессии или не записывает
if [[ -s ~/tmp/ba.txt ]]; then
	#printf "NO_EMPTY \n" # Вывести если ошибка записана и файл не пуст	
	printf "\n"
	printf "╔══════════════════════════════════════════════════════╗\n"
	printf "║Сессия еще не существует, значит мы ее создаем        ║\n"
	printf "╚══════════════════════════════════════════════════════╝\n"
	printf "\n"
	echo -n "Для продолжения нажмите ввод"
	read nothing
	create_sess
else
	#printf "EMPTY \n" # Вывести если ошибка незаписана и файл пуст
	printf "\n"
	printf "╔══════════════════════════════════════════════════════╗\n"
	printf "║Сессия уже существует.                                ║\n"
	printf "╚══════════════════════════════════════════════════════╝\n"
	printf "\n"
	echo -n "Продолжить в старой? y/n: "
	read authorization_decision

	printf "\n"
	printf "╔══════════════════════════════════════════════════════╗\n"
	printf "║Подождите 5 секунд, включаем...                       ║\n"
	printf "╚══════════════════════════════════════════════════════╝\n"
	printf "\n"

	# Блок анализа выбора открыть старую сессию или начать новую?
	authorization_decision_yes="y"
	if [[ "$authorization_decision" = "$authorization_decision_yes" ]]; then
		auth_sess
	else
		create_sess
	fi

fi
